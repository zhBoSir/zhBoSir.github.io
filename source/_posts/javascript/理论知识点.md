---
title: 理论知识点
date: 2020-05-10 22:55:02
categories:
  - JavaScript
tags: 
  - 理论
---

> ## CDN

CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。

<!-- more -->

> ## 虚拟dom

什么是虚拟dom，<code>用javaScript对象表示Dom信息和结构</code>，当状态变更的时候，重新
渲染这个JavaScript的对象结构，这个JavaScript对象成为virtual dom。

所谓虚拟DOM，就是用一个JS对象来描述一个DOM节点，像如下示例：
```
<div class="a" id="b">我是内容</div>

{
  tag:'div',        // 元素标签
  attrs:{           // 属性
    class:'a',
    id:'b'
  },
  text:'我是内容',  // 文本内容
  children:[]       // 子元素
}
```
把组成一个DOM节点的必要东西通过一个JS对象表示出来，那么这个JS对象就可以用来描述这个DOM节点，我们把<code>这个JS对象</code>就称为是这个真实DOM节点的<code>虚拟DOM节点</code>。

<font color="pink">虚拟dom产生的背景：</font>
数据驱动视图，数据发生变化视图就要随之更新，在更新视图的时候难免要操作DOM,而操作真实DOM又是非常耗费性能的，这是因为浏览器的标准就把 DOM 设计的非常复杂。

<code>用JS的计算性能来换取操作DOM所消耗的性能。</code>

既然我们逃不掉操作DOM这道坎,但是我们可以尽可能少的操作DOM。那如何在更新视图的时候尽可能少的操作DOM呢？最直观的思路就是我们不要盲目的去更新视图，而是通过对比数据变化前后的状态，计算出视图中哪些地方需要更新，只更新需要更新的地方，而不需要更新的地方则不需关心，这样我们就可以尽可能少的操作DOM了。这也就是上面所说的用JS的计算性能来换取操作DOM的性能。

我们可以用JS模拟出一个DOM节点，称之为虚拟DOM节点。当数据发生变化时，我们对比变化前后的虚拟DOM节点，通过DOM-Diff算法计算出需要更新的地方，然后去更新需要更新的视图。

这就是虚拟DOM产生的原因以及最大的用途。

> ## 上线部署时出现的问题

vue或者react部署到服务器上时，如果是history模式，刷新会404，这时就需要服务器配置路由重写指向index.html。

> ## cookie的弊端

以前cookie是用来辨认用户的身份。

cookie一方面是不安全（每次发送请求都会出现在请求头里，而且一看就能看到），另一方面是存在跨域方面的问题。所以现在都使用localstorage了。

> ## 浏览器的缓存

浏览器本身有缓存功能。浏览器可能会把上一次的代码存起来，在再次访问的时候没有去请求服务器，而是直接拿的缓存。

<code>强缓存：</code>不发请求到服务器，直接拿缓存。

<code>协商缓存：</code>会请求服务器，服务器告诉你，去拿缓存，还是重新获取数据。

浏览器缓存可以通过后台设置响应头控制。

> ## websocket

使用场景在<code>聊天</code>、<code>客服</code>、<code>在线咨询</code>、<code>即时通讯</code>

### 实现原理有两种：

1. ajax轮询，使用定时器，每隔1s时间发送ajax到后台。（性能不好）

2. websocket（常用）有一个好用的封装socket.io

一般在公司就直接买一个就行了（例如：环信客服），只需要引入它的js就可以了。

websocket通讯是需要前后端配合才能完成的。

> ## DNS解析（域名解析服务器）

1.首先会搜索浏览器自身的DNS缓存

2.如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存

3.如果还没有找到，那么尝试从hosts文件里面去找

4.如果上面都没有找到，就递归去域名服务器查找。

> ## fetch与axios的对比

<code>fetch:</code>

+ 浏览器原生支持的api

+ 原生支持promise

缺点： 
+ 不支持文件上传进度的监测

+ 使用不完美，需要封装

+ 不支持请求中止

+ 默认不带cookie

<code>axios:</code>

+ 支持浏览器和nodejs前后端发请求。
+ 支持promise语法
+ 支持自动解析json
+ 支持中断请求
+ 支持拦截请求
+ 支持请求进度监测
+ 支持客户端防止csrf

> ## XSS与CSRF

<code>XSS跨站脚本攻击。</code>攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据（cookie、session）的一种攻击方式。

<font color="skyblue">防御措施：</font>

+ 输入过滤，避免XSS的方法之一主要是将用户输入的内容进行过滤。对所有用户提交内容进行可靠的输入验证，包括对URL、查询关键字、post数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤（客户端和服务器都要）

+ 转义
```html
<p>123</p>
// 转义
&lt;p&gt;123&lt;/p&gt
```
+ 加httponly请求头，锁死cookie

<code>CSRF跨站请求伪造。</code>即伪造请求，冒充用户在站内的正常操作。绝大多数网站是通过cookie等方式辨识用户身份，再予以授权的。所以要伪造用户的正常操作，最好的方法是通过XSS或链接欺骗等途径，让用户在本机（即拥有身份cookie的浏览器端）发起用户所不知道的请求。

简单理解：以你的名义发送邮件、发送消息等等。

<font color="skyblue">防御措施：</font>

+ 验证请求头HTTP Referer字段，利用HTTP头中Referer判断请求来源是否合法，Referer记录了该HTTP请求的来源地址。

+ 在请求地址中添加token并验证（主流的方式）。要抵御CSRF,关键在于在请求中放入黑客所不能伪造的信息，可以在HTTP请求中以参数的形式加入一个随机产生的token，并在服务器端建立一个拦截器验证这个token。

+ 加验证码（成本较大）
