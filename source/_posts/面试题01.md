---
title: 面试题01
date: 2019-06-26 17:00:00
---

<font color="skyblue"><b>1.把一个字符串的英文字母大小写取反（大写变成小写，小写变成大写）</b></font>

```
let str = "秦腔就像秦人，si不LiWO, hello"

str = str.replace(/[a-zA-Z]/g, content => {
  // content: 每一次正则匹配的结果

  // 第一种解决思路：把字母转换为大写后，看是否和之前一样，一样的话就是大写要转成小写，不一样的话就是小写要转成大写
  return content.toUpperCase() === content ? content.toLowerCase() : content.toUpperCase()

  // 第二种解决思路： 利用ascll码表，大写字母的取值范围在（65~90）
  // if (content.charCodeAt() >= 65 && content.charCodeAt() <= 90) {
  //     return content.toLowerCase()
  // } else {
  //     return content.toUpperCase()
  // }
})

console.log(str) ==>秦腔就像秦人，SI不lIwo, HELLO
```

<code>解析：</code>

replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

语法：stringObject.replace(regexp/substr,replacement)

regexp/substr 必需。规定子字符串或要替换的模式的 RegExp 对象。

replacement  必需。一个字符串值。规定了替换文本或生成替换文本的函数。

如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。

<font color="skyblue"><b>2.求输出的打印结果</b></font>

```
// Foo是构造函数
function Foo() {
  // Foo的私有方法
  Foo.a = function () {
    console.log(1)
  }
  // this指new的实例
  this.a = function () {
    console.log(2)
  }
}
// 把Foo当做类，在原型上设置实例公有的属性方法，这个a方法只有实例才能调用
Foo.prototype.a = function () {
  console.log(3)
}
// 把Foo当做普通对象设置私有的属性方法，这个a方法只有Foo能调用
Foo.a = function () {
  console.log(4)
}

// 下面的输出是：
Foo.a()
let obj = new Foo()  // new实例的时候，也会执行构造函数里的代码，这时把普通对象Foo的a方法变成了输出console.log(1)的构造函数里这个方法
obj.a()  // 一个实例公有和私有上有同名的方法，会优先执行私有上的方法
Foo.a()

最后输出的结果：  
==>  4
==>  2
==>  1
```

<font color="skyblue"><b>3.求输出的打印结果</b></font>
```
var b = 10;
(function b() {
  b = 20
  console.log(b)  // 输出函数
})()
console.log(b)  // 10
```		
解析：

1.自执行函数里面的函数是匿名函数。

2.本应匿名的函数如果设置了函数名，在外面这个函数名还是无法调用，但是在函数里面是可以使用的。在函数里面打印出是函数自己，而且值是不能修改的。

3.自执行函数里的变量都是封闭的不影响外面的变量，所以第二个console.log(b)打印出的是10
		
<font color="gold">=================================</font>

如果想让第一个console.log(b)输出20，怎么办？
```
var b = 10;
(function b() {
  var b = 20
  console.log(b)  // 这里的b为什么输出是20，是因为应为匿名函数却设置了函数名，本就不合法，所以这里会用var b = 20 的b打印结果。
})()
console.log(b)  // 10
```
		
解析：

1.怎么让变量变成函数的私有变量，要么var、let、const等声明下，要么使用形参传递进来。
		
<font color="gold">=================================</font>
```
var b = 10;
(function() {
  b = 20  // b没有声明提升为全局变量。
  console.log(b)  // 20
})()
console.log(b)  // 20
```		
		
<font color="gold">=================================</font>
```
let fn = function aaa() {
  console.log(aaa)
}
fn()  // =====> 可以调用
// aaa() ====> 不可以调用，会报错。因为已经let定义了fn变量，等于后面应该是一个匿名函数
```	

解析：

1.本应匿名的函数如果设置了函数名，在外面这个函数名（例中的aaa函数）还是无法调用，但是在函数里面是可以使用的。

2.这种本应匿名的函数如果设置了函数名，就类似创建常量一样，这个名字存储的值不能再修改（非严格模式下不报错，但是不会有任何的效果，严格模式下直接报错，我们可以把aaa理解为是用const创建出来的）。例如fn()执行，打印出来的就是aaa函数。

<font color="skyblue"><b>4.将数组var a=[1, 2, 3]变成数组[4, 3, 2, 1]下面的方式正确的是？</b></font>

A. a.reverse().unshift(4)

B. a.push(4).reverse()

C. a.push(4); a.reverse()

D. a.splice(3, 1, 4).reverse()

正确答案：A和C

<font color="gold">解析：</font>

B选项因为a.push(4)返回的是数组的长度（即是4），4.reverse()当然不正确。

相关知识点：

<code>1.</code>push() 方法可向数组的末尾添加一个或多个元素，并返回新的长度。

<code>2.</code>pop() 方法用于删除并返回数组的最后一个元素。

<code>3.</code>push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。

<hr>

C选项的解析a.splice(3, 1, 4)返回的是删除元素组成的数组，因为删除元素是空，所以返回一个空数组，所以[].reverse()也不对。

相关知识点：

<code>1.</code>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。

<code>2.</code>

```js
arrayObject.splice(index,howmany,item1,.....,itemX)

// index	必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。

//howmany	必需。要删除的项目数量。如果设置为 0，则不会删除项目。

//item1, ..., itemX	可选。向数组添加的新项目。

//返回值
//Array	包含被删除项目的新数组，如果有的话。
```
splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。
如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。

